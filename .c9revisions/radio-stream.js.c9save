{"ts":1360569001962,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360569012719,"patch":[[{"diffs":[[1,"const R = '\\r'.charCodeAt(0);\nconst N = '\\n'.charCodeAt(0);\nconst META_BLOCK_SIZE = 16;\n\nvar net = require(\"net\");\nvar parse = require(\"url\").parse;\nvar EventEmitter = require(\"events\").EventEmitter;\n\n\n/**\n * Create's an Internet Radio `ReadStream`. It emits \"data\" events similar to\n * the `fs` module's `ReadStream`, but never emits an \"end\" event (it's an infinite\n * radio stream). The Internet Radio `ReadStream` also emits a \"metadata\" event\n * which occurs after a metadata chunk has been recieved and parsed, for your\n * Node application to do something useful with.\n */\nfunction ReadStream(url, retainMetadata) {\n    var self = this;\n\n    this.url = new String(url);  \n    var parsedUrl = parse(url);\n    parsedUrl.__proto__ = this.url.__proto__;\n    this.url.__proto__ = parsedUrl;\n    this.errorMessage = '';\n    this.reconnectTimeoutInSeconds = 1;\n  \n    this.retainMetadata = retainMetadata;\n\n\n    this.initializeConnection.call(this);\n\n    // this.connection = net.createConnection(this.url.port || (this.url.protocol == \"https:\" ? 443 : 80), this.url.hostname);\n    // this.connection.on(\"connect\", this.onConnect.bind(this));\n    // this.connection.on(\"close\", this.onClose.bind(this));\n    // this.connection.on(\"error\", function(e) {\n    //   console.error('url failed. url: ' + url + ', ex.code: ' + e.code);\n    //   self.errorMessage = e.code;\n    // })\n\n    // this.headerBuffer = null;\n    // this.bindedOnMetaData = this.onMetaData.bind(this);\n    // this.bindedOnMetaLengthByte = this.onMetaLengthByte.bind(this);\n    // this.connection.on(\"data\", (this.bindedOnData = this.onDataHeader.bind(this)));\n  \n    // // The counter used to keep track of count of the audio/metadata bytes parsed.\n    // this.counter = 0;\n}\nexports.ReadStream = ReadStream;\n\n// Make `ReadStream` inherit from `EventEmitter`\nReadStream.prototype = Object.create(EventEmitter.prototype, {\n    constructor: {\n        value: ReadStream,\n        enumerable: false\n    }\n});\n\nexports.appendBuffer = function(a, b) {\n    var temp = new Buffer(a.length + b.length);\n    a.copy(temp, 0, 0);\n    b.copy(temp, a.length, 0);\n    return temp;\n}\n\nReadStream.prototype.initializeConnection = function() {\n    this.connection = net.createConnection(this.url.port || (this.url.protocol == \"https:\" ? 443 : 80), this.url.hostname);\n    this.connection.on(\"connect\", this.onConnect.bind(this));\n    this.connection.on(\"close\", this.onClose.bind(this));\n    this.connection.on(\"error\", (function(e) {\n        this.emit(\"error\", e.code);\n    }).bind(this))\n\n    this.headerBuffer = null;\n    this.bindedOnMetaData = this.onMetaData.bind(this);\n    this.bindedOnMetaLengthByte = this.onMetaLengthByte.bind(this);\n    this.connection.on(\"data\", (this.bindedOnData = this.onDataHeader.bind(this)));\n\n    // The counter used to keep track of count of the audio/metadata bytes parsed.\n    this.counter = 0;\n}\n\n\n// Once connected, send a minimal HTTP response to radio stream.\nReadStream.prototype.onConnect = function() {\n    this.connection.write(this.generateRequest());\n}\n\n// Called when the underlying \"net\" Stream emits a \"data\" event.\nReadStream.prototype.onData = function(chunk) {\n    if (this.metaint && this.counter == this.metaint) {\n        //console.error(\"Audio Bytes Recieved: \" + this.counter);\n        this.counter = 0;\n        this.connection.removeListener(\"data\", this.bindedOnData);\n        this.connection.addListener(\"data\", this.bindedOnMetaLengthByte);\n        this.connection.emit(\"data\", chunk);\n    \n    } else if (this.metaint && this.counter + chunk.length >= this.metaint) {\n        var audioEnd = this.metaint - this.counter;\n        var audioChunk = chunk.slice(0, audioEnd);\n        //console.error(\"Audio Chunk Before MetaData: \" + audioChunk.length);\n        this.emit(\"data\", audioChunk);\n        //console.error(this.counter+\"+\"+audioChunk.length+\"= \" + (this.counter + audioChunk.length));\n        this.counter += audioChunk.length;\n\n        // There's still remaining data! It should be metadata!\n        if (chunk.length != audioChunk.length) {\n            var metadata = chunk.slice(audioEnd, chunk.length);\n            this.connection.emit(\"data\", metadata);      \n        }\n    \n    } else if (chunk.length) {\n        this.emit(\"data\", chunk);\n        //console.error(this.counter+\"+\"+chunk.length+\"= \" + (this.counter + chunk.length) + \"   Value: \" + chunk[0]);\n        this.counter += chunk.length;\n    }\n}\n\nReadStream.prototype.onClose = function(had_error) {\n    this.connection.removeAllListeners();\n    this.connection.destroy();\n\n    this.reconnectTimeoutInSeconds *= 2;\n    // this.emit(\"close\", had_error);\n    this.emit(\"reconnect\", had_error);\n\n    var self = this;\n    setTimeout(function(){ self.initializeConnection.bind(self)(); }, this.reconnectTimeoutInSeconds * 1000);\n}\n\n// Called when the underlying \"net\" Stream emits a \"data\" event.\nReadStream.prototype.onDataHeader = function(chunk) {\n    // Append 'chunk' into the 'response' variable\n    if (this.headerBuffer) {\n        this.headerBuffer = exports.appendBuffer(this.headerBuffer, chunk);\n    } else {\n        this.headerBuffer = chunk;\n    }\n\n    // If there's less than 8 bytes, it's still an unplausable response header,\n    // don't even bother checking this time around, check the next 'data' event.\n    if (this.headerBuffer.length < 8) return;\n  \n    // Check to see if the end of the header has been reached.\n    // If so we need to determine what kind of response we got.\n    for (var i=0, l=Math.min(this.headerBuffer.length-3, 8192); i<l; i++) {\n        // Check for /r/n/r/n\n        if (this.headerBuffer[i] == R && this.headerBuffer[i+1] == N && this.headerBuffer[i+2] == R && this.headerBuffer[i+3] == N) {\n            // We found the end of the header!\n\n            var leftover = this.headerBuffer.slice(i+4, this.headerBuffer.length);\n            this.headerBuffer = this.headerBuffer.slice(0, i);\n\n            this.parseHeaders();\n\n            this.connection.removeListener(\"data\", this.bindedOnData);\n            this.connection.addListener(\"data\", (this.bindedOnData = this.onData.bind(this)));\n      \n            // Emit the \"connect\" event. The headers are parsed now, so the user can\n            // inspect them, and set up `ffmpeg` based on the 'content-type' perhaps?\n            this.emit(\"connect\", this);\n\n            // If there are any bytes leftover after the header, then it's audio data that should\n            // be handled by the new 'onData' callback, then passed back to the user.\n            if (leftover.length > 0) {\n                this.connection.emit(\"data\", leftover);\n            }\n            return;\n        }\n    }\n}\n\n// Called when the underlying \"net\" Stream emits a \"data\" event.\nReadStream.prototype.onMetaData = function(chunk) {\n\n    if (this.counter + chunk.length >= this.metaLength) {\n        var metaEnd = this.metaLength - this.counter - 1;\n        this.counter += metaEnd;\n        var metaChunk = chunk.slice(0, metaEnd);\n    \n        if (this.metaBuffer) {\n            this.metaBuffer = exports.appendBuffer(this.metaBuffer, metaChunk);\n        } else {\n            this.metaBuffer = metaChunk;\n        }\n        this.emit(\"metadata\", this.metaBuffer.toString());\n        this.reconnectTimeoutInSeconds = 1;\n\n        //console.error(\"Meta Bytes Recieved: \" + this.counter + \", \" + this.metaBuffer.length);\n        this.metaBuffer = null;\n        this.metaLength = null;\n\n        this.counter = 0;\n        this.connection.removeListener(\"data\", this.bindedOnMetaData);\n        this.connection.addListener(\"data\", this.bindedOnData);\n        if (metaEnd+1 < chunk.length) {\n            var remainder = chunk.slice(metaEnd+1, chunk.length);\n            //console.error(remainder.slice(0, Math.min(5, remainder.length)));\n            this.connection.emit(\"data\", remainder);\n        }\n    } else {\n        if (this.metaBuffer) {\n            this.metaBuffer = exports.appendBuffer(this.metaBuffer, chunk);\n        } else {\n            this.metaBuffer = chunk;\n        }\n        this.counter += chunk.length;\n    }\n}\n\n// Called when the underlying \"net\" Stream emits a \"data\" event.\n// 'chunk' is guaranteed to be at least 1 byte long.\nReadStream.prototype.onMetaLengthByte = function(chunk) {\n  \n    var metaByte = chunk[0];\n    //console.error(\"MetaByte: \" + metaByte);\n  \n    this.metaLength = metaByte * META_BLOCK_SIZE;\n    //console.error(\"MetaData Length: \" + this.metaLength);\n\n    this.counter = 0;\n    this.connection.removeListener(\"data\", this.bindedOnMetaLengthByte);\n    this.connection.addListener(\"data\", this.metaLength ? this.bindedOnMetaData : this.bindedOnData);\n    var remains = chunk.slice(1, chunk.length);\n    this.connection.emit(\"data\", remains);\n}\n\nReadStream.prototype.generateRequest = function() {\n    return \"GET \" + (this.url.pathname ? this.url.pathname : \"/\") + (typeof this.url.search === 'string' ? this.url.search : \"\") + \" HTTP/1.1\\r\\n\"+\n      \"Host: \" + this.url.host + \"\\r\\n\"+\n      \"Icy-MetaData:1\\r\\n\"+\n      \"user-agent: WinampMPEG/5.09\\r\\n\"+\n      \"\\r\\n\";\n}\n\nReadStream.prototype.parseHeaders = function() {\n    this.headerString = this.headerBuffer.toString();\n\n    // If it's an ICY stream / raw HTTP stream (check content-type), make return the URL itself\n    var firstLine = this.headerString.substring(0, this.headerString.indexOf(\"\\r\")).split(\" \");\n  \n    // It's an ICY stream\n    if (firstLine[0] == \"ICY\") {\n        //console.error(\"Detected an ICY stream!\");\n    }\n  \n    this.headers = {};\n    var headers = this.headerString.split(\"\\r\\n\").slice(1);\n    for (var i=0, l=headers.length; i<l; i++) {\n        var header = headers[i].split(\":\");\n        this.headers[header[0].trim()] = header[1].trim();\n    }\n  \n    // Permenantly store the metaint\n    Object.defineProperty(this, \"metaint\", {\n        value: this.headers['icy-metaint'],\n        enumerable: false,\n        writable: true\n    });\n  \n}\n\n\n// Returns a new ReadStream for the given Internet Radio URL.\n// First arg is the URL to the radio stream. Second arg is a\n// boolean indicating whether or not to include the metadata\n// chunks in the 'data' events. Defaults to 'false' (metadata,\n// is stripped, parsed, and formatted into the 'metadata' event).\nfunction createReadStream(url, retainMetadata) {\n    return new ReadStream(url, retainMetadata);\n}\nexports.createReadStream = createReadStream;\n\n\n\n\n\n\n// Used to strip 'null' bytes from the metadata event\nvar nullExp = new RegExp('\\0', 'g');\n/**\n * Accepts the Buffer passed from the 'metadata' event, and parses it into\n * a JavaScript object.\n */\nfunction parseMetadata(metadata) {\n    var rtn = {}, pieces = metadata.toString().replace(nullExp, '').split(\";\");\n    for (var i=0, l=pieces.length; i<l; i++) {\n        var piece = pieces[i];\n        if (piece.length) {\n            piece = piece.split(\"='\");\n            if (piece.length >=2)\n                rtn[piece[0]] = piece[1].substring(0, piece[1].length-1);\n        }\n    }\n    return rtn;\n}\nexports.parseMetadata = parseMetadata;"]],"start1":0,"start2":0,"length1":0,"length2":11009}]],"length":11009,"saved":false}
